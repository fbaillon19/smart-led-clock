/**
 * Smart LED Clock - Main Arduino Sketch
 * 
 * A multi-functional LED clock with temperature monitoring, air quality sensing,
 * and web-based configuration interface.
 * 
 * Features:
 * - Visual LED clock display with 60 LED minute/second ring and 12 LED hour ring
 * - Indoor and outdoor temperature/humidity monitoring (DHT22)
 * - Air quality monitoring with LED bar display (MQ135)
 * - 20x4 LCD display for detailed information
 * - Web interface for configuration and monitoring
 * - NTP time synchronization
 * - Hourly animations
 * - Multiple display modes controlled by buttons
 * 
 * Author: F. Baillon
 * Email: fbaillon@gmail.com
 * Version: 1.0
 * Date: January 2025
 * License: GPL v3.0
 * 
 * Hardware Requirements:
 * - Arduino UNO R4 WiFi
 * - 3x WS2812B LED strips (60, 12, and 10 LEDs)
 * - 2x DHT22 temperature/humidity sensors
 * - MQ135 air quality sensor
 * - 20x4 I2C LCD display
 * - 2x push buttons
 * - 5V 5A power supply
 */

// ==========================================
// INCLUDE LIBRARIES AND HEADERS
// ==========================================

// Standard Arduino libraries
#include <Wire.h>

// Third-party libraries
#include <Adafruit_NeoPixel.h>
#include <DHT.h>
#include <LiquidCrystal_I2C.h>
#include <OneButton.h>
#include <NTPClient.h>
#include <WiFiS3.h>
#include <WiFiUdp.h>
#include <RTClib.h>  // For DS3231 RTC module

// Project configuration and modules
#include "config.h"
#include "secrets.h"
#include "time_manager.h"
#include "sensors.h"
#include "display_utils.h"
#include "button.h"
#include "web_interface.h"

// ==========================================
// GLOBAL OBJECT DECLARATIONS
// ==========================================

// LED strip objects
Adafruit_NeoPixel ledsHour(NUM_LEDS_HOUR, PIN_LEDS_HOUR, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel ledsMinuteSec(NUM_LEDS_MINUTE_SECOND, PIN_LEDS_MINUTE_SECOND, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel ledsAirQuality(NUM_LEDS_AIR_QUALITY, PIN_LEDS_AIR_QUALITY, NEO_GRB + NEO_KHZ800);

// Sensor objects
DHT dhtIndoor(PIN_DHT_INDOOR, DHT_TYPE);
DHT dhtOutdoor(PIN_DHT_OUTDOOR, DHT_TYPE);

// Display and input objects
LiquidCrystal_I2C lcd(LCD_I2C_ADDRESS, LCD_COLUMNS, LCD_ROWS);
OneButton button1;
OneButton button2;

// Network objects
WiFiUDP udp;
NTPClient timeClient(udp);
WiFiServer webServer(WEB_SERVER_PORT);

// DS3231 RTC object
RTC_DS3231 rtc;

// ==========================================
// GLOBAL VARIABLES
// ==========================================

// System state
volatile bool secondTickFlag = false;  // Second interrupt flag (now from timer, not RTC)
unsigned long lastSensorUpdate = 0;    // Last sensor reading timestamp
unsigned long lastSecondUpdate = 0;    // For manual second timing
bool systemInitialized = false;        // System initialization complete

// RTC specific variables
bool rtcInitialized = false;           // DS3231 initialization status
unsigned long lastRTCSync = 0;         // Last NTP sync timestamp
float rtcTemperature = 0.0;            // DS3231 temperature reading

// Display state
DisplayMode currentDisplayMode = MODE_TEMP_HUMIDITY;
bool isTemporaryDisplay = false;
unsigned long temporaryDisplayTimer = 0;
bool isPermanentFeelsLike = false;

// Animation state
bool isAnimationActive = false;
int animationCounter = 0;
int animationStep = 0;
int animationHue = 0;

// Time tracking
unsigned short lastSecond = 61;  // Force initial update
unsigned short lastMinute = 61;
unsigned short lastHour = 25;

// Sensor data storage
TemperatureData indoorData = {0, 0, 0, 0, 0, false, 0};
TemperatureData outdoorData = {0, 0, 0, 0, 0, false, 0};
AirQualityData airQualityData = {0, 0, "Unknown", 0, false, 0};

// Web configuration
WebConfig config = {
  .ledBrightness = 100,
  .nightModeEnabled = true,
  .nightModeStart = 22,
  .nightModeEnd = 7,
  .animationsEnabled = true,
  .sensorUpdateInterval = 2,
  .debugMode = false
};

bool isWebServerRunning = false;
unsigned long lastWebActivity = 0;

// Button state variables (defined in button.h)
bool button1Pressed = false;
bool button2Pressed = false;
unsigned long lastButtonAction = 0;
byte degreeSymbol[8] = {
  0b01100,
  0b10010,
  0b10010,
  0b01100,
  0b00000,
  0b00000,
  0b00000,
  0b00000
};

// ==========================================
// SETUP FUNCTION
// ==========================================

void setup() {
  // Initialize serial communication
  Serial.begin(SERIAL_BAUD_RATE);
  delay(1000); // Allow serial to stabilize
  
  Serial.println("=== Smart LED Clock v1.0 ===");
  Serial.println("Initializing system...");

  // Initialize display first for status messages
  initDisplay();
  displayStartupMessage("Smart LED Clock v1.0");
  
  // Initialize hardware modules
  if (!initializeHardware()) {
    Serial.println("ERROR: Hardware initialization failed!");
    displayStartupMessage("Hardware Init Failed!");
    while(1) delay(1000); // Halt on critical error
  }

  // Initialize sensors
  initSensors();
  displayStartupMessage("Sensors initialized");
  delay(1000);

  // Initialize time management with DS3231
  initTimeManager();
  displayStartupMessage("Checking DS3231 RTC...");
  
  if (setupDS3231RTC()) {
    Serial.println("DS3231 RTC initialized successfully");
    displayStartupMessage("DS3231 RTC Ready");
  } else {
    Serial.println("WARNING: DS3231 RTC initialization failed!");
    displayStartupMessage("DS3231 RTC Error");
  }
  delay(1000);

  displayStartupMessage("Connecting WiFi...");
  
  if (synchronizeDS3231WithNTP()) {
    Serial.println("Time synchronized with NTP successfully");
    displayStartupMessage("Time synchronized");
  } else {
    Serial.println("WARNING: NTP sync failed, using DS3231 time");
    displayStartupMessage("Using RTC time");
  }
  delay(1000);

  // Initialize web server
  displayStartupMessage("Starting web server...");
  if (initWebServer()) {
    Serial.println("Web server started successfully");
    displayStartupMessage("Web server ready");
  } else {
    Serial.println("WARNING: Web server failed to start");
    displayStartupMessage("Web server failed");
  }
  delay(1000);

  // Load saved configuration
  loadWebConfig();
  
  // Apply initial settings
  applyLEDBrightness(config.ledBrightness);
  
  // Manual timing setup (since we're not using Arduino UNO R4 internal RTC callbacks)
  lastSecondUpdate = millis();

  // System ready
  systemInitialized = true;
  Serial.println("System initialization complete!");
  
  displayStartupMessage("System Ready!");
  delay(2000);
  
  // Clear LCD and start normal operation
  clearLCDDisplay();
  currentDisplayMode = MODE_TEMP_HUMIDITY;

  Serial.println("Entering main loop...");
}

// ==========================================
// MAIN LOOP
// ==========================================

void loop() {
  static unsigned long lastAnimationUpdate = 0;
  static DateTime currentTime;

  // Process button inputs
  processButtons();

  // Handle web server requests
  if (isWebServerRunning) {
    handleWebServer();
  }

  // Manual second tick generation (replace RTC callback)
  if (millis() - lastSecondUpdate >= 1000 && !isAnimationActive && !isTemporaryDisplay) {
    lastSecondUpdate = millis();
    
    // Get current time from DS3231
    currentTime = getCurrentTime();
    
    // Check if DS3231 is responding
    if (checkRTCHealth()) {
      // Update LED clock display
      updateLEDClock(currentTime);
      
      // Check for hourly animation trigger
      if (hasHourChanged(currentTime) && config.animationsEnabled) {
        startHourlyAnimation();
      }
      
      // Check for daily NTP sync
      if (shouldSyncNTP(currentTime)) {
        Serial.println("Performing daily NTP sync...");
        synchronizeDS3231WithNTP();
      }

#if ENABLE_SERIAL_DEBUG
      debugPrintTime(currentTime);
      // Print RTC diagnostics every 30 seconds
      static unsigned long lastDiagnostic = 0;
      if (millis() - lastDiagnostic >= 30000) {
        debugPrintRTCDiagnostics();
        lastDiagnostic = millis();
      }
#endif
    } else {
      Serial.println("ERROR: DS3231 RTC communication failed!");
      if (handleRTCError()) {
        Serial.println("DS3231 RTC recovered successfully");
      }
    }
  }

  // Handle hourly animation
  if (isAnimationActive) {
    unsigned long now = millis();
    if (now - lastAnimationUpdate >= 50) { // 50ms animation frame rate
      if (!updateAnimation()) {
        stopAnimation(); // Animation finished
      }
      lastAnimationUpdate = now;
    }
  }

  // Update sensors periodically
  if (updateAllSensors()) {
    // New sensor data available, update air quality display
    updateAirQualityDisplay();
  }

  // Update LCD display
  updateLCDDisplay();

  // Apply night mode if enabled
  if (config.nightModeEnabled) {
    applyNightModeSettings();
  }

  // Small delay to prevent overwhelming the system
  delay(10);
}

// ==========================================
// INITIALIZATION FUNCTIONS
// ==========================================

/**
 * Initialize DS3231 RTC module
 * @return true if all hardware initialized successfully
 */
bool initializeHardware() {
  bool success = true;

  // Initialize I2C communication first (needed for DS3231 and LCD)
  Wire.begin();
  Serial.println("I2C bus initialized");

  // Initialize LED strips
  ledsHour.begin();
  ledsMinuteSec.begin();
  ledsAirQuality.begin();
  
  // Clear all LEDs
  ledsHour.clear();
  ledsMinuteSec.clear();
  ledsAirQuality.clear();
  ledsHour.show();
  ledsMinuteSec.show();
  ledsAirQuality.show();

  Serial.println("LED strips initialized");

  // Initialize buttons
  initButtons();
  Serial.println("Buttons initialized");

  // Initialize air quality sensor pin
  pinMode(PIN_AIR_QUALITY_SENSOR, INPUT);
  Serial.println("Air quality sensor initialized");

  return success;
}

// ==========================================
// RTC CALLBACK FUNCTION (Legacy - now unused)
// ==========================================

/**
 * Legacy RTC callback function - no longer used with DS3231
 * Time updates are now handled manually in main loop
 */
void rtcSecondCallback() {
  // This function is kept for compatibility but not used
  // DS3231 timing is handled manually in main loop
}

// ==========================================
// DEBUG FUNCTIONS
// ==========================================

#if ENABLE_SERIAL_DEBUG
/**
 * Print system status for debugging
 */
void debugPrintSystemStatus() {
  Serial.println("=== System Status ===");
  Serial.print("Free memory: ");
  Serial.println(getMemoryUsageString());
  Serial.print("Uptime: ");
  Serial.println(getUptimeString());
  Serial.print("WiFi status: ");
  Serial.println(WiFi.status());
  Serial.println("====================");
}
#endif

// ==========================================
// UTILITY FUNCTIONS
// ==========================================

/**
 * Software reset function - Updated for Arduino UNO R4
 * Restarts the Arduino (useful for web interface)
 */
void softwareReset() {
  Serial.println("Performing software reset...");
  delay(1000);
  
  // Use NVIC reset for ARM-based Arduino UNO R4
  #if defined(ARDUINO_UNOWIFIR4)
    NVIC_SystemReset();
  #else
    // Fallback for other architectures
    void(*resetFunc)(void) = 0;
    resetFunc();
  #endif
}

/**
 * Check system health and report issues
 * @return true if system is healthy
 */
bool checkSystemHealth() {
  bool healthy = true;
  
  // Check sensor data freshness
  if (!isSensorDataFresh(indoorData.lastUpdate)) {
    Serial.println("WARNING: Indoor sensor data stale");
    healthy = false;
  }
  
  if (!isSensorDataFresh(outdoorData.lastUpdate)) {
    Serial.println("WARNING: Outdoor sensor data stale");
    healthy = false;
  }
  
  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WARNING: WiFi disconnected");
    healthy = false;
  }
  
  return healthy;
}

// ==========================================
// END OF MAIN SKETCH
// ==========================================